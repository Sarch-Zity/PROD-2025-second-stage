#  Задача 5 | Товарная витрина – логика, обработка данных и подготовка отображения

[⬅️ назад](../README.md)

## ТЗ

Необходмио реализовать логику коллекции с товарами


#### IProductViewModelFactory
Ожидаются методы

- makeProductViewModel

ViewModel:

1. Берем доступные данные as is
2. weight » значение веса + " " + единица измерения (г или кг)
3. Цена в формате "1 500 ₽"
4. изображение по imageId
5. Текст кнопки (если товаров в корзине больше 0)
    1. формат – "%число товаров% шт. = %сумма%"
    2. сумму получаем путем умножения цены на число товаров. Итоговый формат – "1 500 ₽"
6. Бейджи
    1. topBadge (Бонус) 
        1. Берем массив бонусов из товара
        2. (пунтк 2) Берем доступные пользователю available_bonuses
        3. (пунтк 3) Берем инфу о всех бонусах. Оставляем из них только активные. Активный бонус если
            1. нет available_due_to
            2. есть available_due_to и он еще не наступил (то есть бонус еще актуальный)
        4. Выбираем бонус – берем первый бонус из массива у товара (пункт 1), который 
            1. активный (пунтк 3) 
            2. доступен пользователю (пунтк 2)
        5. Значение
            1. Получаем value (помним, что кэшбэк это дробь, а мы показываем проценты)
            2. Если есть promotion_extra, то
                1. Передаем цвета из модели
                2. Формируем лейбл как 
                    - для кэщбэков – "{label} • {value}%"
                    - для баллов – "{label} • {value} Б"
            3. Если нет promotion_extra, то
                - для кэщбэков – "Кэшбэк {value}%"
                - для баллов – "{value} баллов"
    2. bottomBadge
        1. Смотрим на модель инфы о пользователе. 
        2. Если выбранный товар есть в favourites, то показываем "Любимое ❤️"
        3. Если же товара нет в favourites, но isNew == true, то "Новинка" и цвет текста = "F8AA1B"

#### Сортировка
1. Для каждого товара надо посчитать score.
    1. Популярность товара ("popularity"): если больше 100, то +3 к Score, если менее 50, то -1 к рейтингу, иначе оставляем Score неизменным.
    2. Оценка пользователей ("rating"): 
        1. если больше 4.5, то +2 к Score, если меньше 3, то -1 к Score, иначе оставляем рейтинг неизменным.
        2. если рейтинга нет – не меняем
    3. "Любимое": если товар в `favourites`, то +2 
    4. Предпочтения пользователя: определяем историю покупок пользователя (поле `last_goods_cat`), индекс каждого элемента с конца списка добавляем к Score. Например, у пользователя история покупок ["category1", "category2", "category3", "category4"]. Тогда category4 получит +0, category3 получит +1, category2 получит +2, category1 получит +3.. При отсутсвии в списке тоже +0
2. по значению Score сортируем (по убыванию). Сортировка в IProductsDataSource

#### IButtonsViewInteractionModel
Необходио реализовать методы из протокола `IButtonsViewInteractionModel`. 

При этом по нажатию на "Добавить" и "+"
- увеличивать количество выбранных товаров в корзине на 1

При нажатии на "-"
- уменьшать количество выбранных товаров в корзине на 1

! кроме того. `IProductView` должно реагировать на изменения в хранилище. То есть при изменении количества товаров в корзине нужно переконфигурировать отображение кнопки (получить актуальное значение числа элементов в корзине)  

## Ожидаемое решение

- Необходимо реализовать `IProductViewModelFactory`, который формирует отображение.

- Реализовать `IProductsDataSource`, который сортирует товары

- `IButtonsViewInteractionModel` – логика нажатия на кнопки товара. Плюс в `IProductView` также нужно внести изменения по реагированию на изменения корзины
