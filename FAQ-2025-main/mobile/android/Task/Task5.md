# Задача 5 | Товарная витрина – логика, обработка данных и подготовка отображения

[⬅️ назад](../README.md)

## ТЗ

Необходимо реализовать логику формирования списка товаров для отображения на главном экране
приложения.

### GoodInfoToUiModelMapperImpl

Необходимо реализовать метод `GoodInfoToUiModelMapper.mapGoodInfoToUiModel()` для перевода
из API данных о товаре в данные для отображения на главном экране.
Можно пользоваться объектом `Const` из модуля `:core-api` при описании логики, чтобы избежать ошибок
с несовпаденим символов.

1. Берем доступные данные as is
2. Id изображения конвертируется в id ресурса при помощи метода `imageIdToResId()`.
3. Вес товара формируется следующим образом: значение веса + " " + единица измерения (г или кг).
   Единица измерения может принмать два значения: "kilo", "gramm".
4. Цена в формате: "1500 ₽".
5. Текст кнопки (если товаров в корзине больше 0)
    1. Формат – "${число товаров}шт. = $сумма ₽".
    2. Cумму получаем путем умножения цены на число товаров.
6. Лейблы
    1. `GoodsFavouriteUi`
        1. Смотрим на модель инфы о пользователе.
        2. Если выбранный товар есть в favourites, то показываем "Любимое ❤️"
        3. Если же товара нет в favourites, но isNew == true, то "Новинка" и цвет текста = "#F8AA1B"
    2. `GoodsBonusUi`
        1. Смотрим на модель инфы о бонусе.
        2. Формируем значение (помним, что кэшбэк это дробь, а мы показываем проценты)
        3. Если есть promotion_extra, то
            1. Передаем цвета из модели
                1. tintColor - цвет текста
                2. baseColor - цвет фона
            2. Формируем лейбл как
                - для кэшбэков – "{label} • {value}%"
                - для баллов – "{label} • {value} Б"
            3. Если нет promotion_extra, то
                - для кэшбэков – "Кэшбэк {value}%"
                - для баллов – "{value} баллов"

**Формат входных данных**

На вход в `GoodInfoToUiModelMapper` поступает:

1. `goods: GoodInfo` - информация о товаре
2. `quantity: Int` - количество товара в корзине
3. `userInfo: UserInfo` - информация о пользователе
4. `bonusInfo: BonusInfo?` - информация о подходящем бонусе товара (
   `GetBonusInfoFromGoodInfoUseCase` далее)

**Формат выходных данных**

На выход из `GoodInfoToUiModelMapper` должен быть возвращен объект класса `GoodsItemUi`

---

### GetBonusInfoFromGoodInfoUseCaseImpl

Необходимо реализовать сервис для выбора подходящего бонуса конкретного товара.

1. (пункт 1) Берем массив бонусов из товара
2. (пункт 2) Берем доступные пользователю `available_bonuses`
3. (пункт 3) Берем инфу о всех бонусах. Оставляем из них только активные. Активный бонус если
    1. нет `available_due_to`
    2. есть `available_due_to` и он еще не наступил (то есть бонус еще актуальный)
4. Выбираем бонус – берем первый бонус из массива у товара (пункт 1), который
    1. активный (пункт 3)
    2. доступен пользователю (пункт 2)

**Формат входных данных**

На вход в `GetBonusInfoFromGoodInfoUseCase` поступает информация о товаре `GoodInfo`

**Формат выходных данных**

На выход из `GetBonusInfoFromGoodInfoUseCase` должен быть возвращен объект класса
`BonusInfo` или `null` если не нашли подходящий бонус.

---

### GoodsScoreCalculatorImpl

Необходимо реализовать сервис для подсчета Score товара.

1. Популярность товара ("popularity"): если больше 100, то +3 к Score, если менее 50, то -1 к
   рейтингу, иначе оставляем Score неизменным.
2. Оценка пользователей ("rating"):
    1. если больше 4.5, то +2 к Score; если меньше 3, то -1 к Score; иначе оставляем рейтинг
       неизменным.
    2. если рейтинга нет – не меняем
3. "Любимое": если товар в `favourites`, то +2
4. Предпочтения пользователя: определяем историю покупок пользователя (поле `last_goods_cat`),
   индекс каждого элемента с конца списка добавляем к Score. Например, у
   пользователя история покупок ["category1", "category2", "category3", "category4"]. Тогда
   category4 получит +0, category3 получит +1, category2 получит +2, category1 получит +3..
   При отсутсвии в списке тоже +0.

**Формат входных данных**

На вход в `GoodsScoreCalculator` поступает информация о товаре `GoodInfo`
и информация о пользователе `UserInfo`.

**Формат выходных данных**

На выход из `GoodsScoreCalculator` должно быть возращено целосчисленное значение, определяющее Score
товара.

---

### GoodsInfoSorterImpl

Необходимо релизовать сортировщик товаров на основе предпочтений пользователя (score).
Score товара можно рассчитать с помощью `GoodsScoreCalculator.calculateScore()`.
Сортировка должна быть **по убыванию** score.

**Формат входных данных**

На вход в `GoodsInfoSorter` поступает информация о товаре `GoodInfo`
и информация о пользователе `UserInfo`.

**Формат выходных данных**

На выход из `GoodsInfoSorter` должен быть возвращен отсортированные по убыванию
список товаров в соотвествии со score каждого товара.

---

### GetGoodsUseCaseImpl

Необходимо реализовать UseCase для загрузки элементов витрины товаров, готовой для отображения на
главном экране.
Основной задачей является сбор и формирование списка объектов `GoodsItemUi` с помощью классов,
реализованных ранее.

1. Загружаем все доступные данные
2. Сортируем список товаров с помощью `GoodsInfoSorter.sortGoodsInfo()`
3. Трансформируем каждый элемент списка товаров
    1. Получаем количество товаров в корзине
    2. Получаем подходящий бонус для этого товара с помощью
       `GetBonusInfoFromGoodInfoUseCase.getBonusInfo()`
    3. Формруем и получаем `GoodsItemUi` с помощью `GoodInfoToUiModelMapper.mapGoodInfoToUiModel()`

**Формат выходных данных**

На выход из `GetGoodsUseCase` должен быть возвращен список объектов `GoodsItemUi`,
готовый для отображения на главном экране витрины.

## Ожидаемое решение

- Необходимо реализовать `GoodInfoToUiModelMapperImpl`, который мапит данные из API модели в UI.
- Необходимо реализовать `GetBonusInfoFromGoodInfoUseCaseImpl`, который отдает подходящий бонус для
  товара.
- Необходимо реализовать `GoodsScoreCalculatorImpl`, который подсчитывает score для каждого товара.
- Необходимо реализовать `GoodsInfoSorterImpl`, который сортирует товары в соответсвии с его score.
- Необходимо реализовать `GetGoodsUseCaseImpl`, который формирует итоговый список объектов
  `GoodsItemUi`.
